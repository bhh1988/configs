! To refresh your understanding of how key input is transformed and interpreted from the X server to the client, see the wikipedia article on "X Window System core protocol" in the "Mappings" section.

! The important thing to know is that the X server is in charge of two things regarding keyboard input: maintaining a keycode->keysym and modifier map, and reporting key events (KeyPress or KeyRelease) to the client. First, the maps it maintains: the maps are global maps so that all clients may refer to them. The first kind of map is a keycode->keysym map. Pressing a key generates a keycode in the X server. Each physical key on the keyboard has a unique keycode and this physicalkey->keycode mapping is not something that we change. The interpretation of the keycode is a keysym, and this map is maintained by the X server and can be modified by xmodmap. Multiple keycodes may map to the same keysym (for example, having both the 'CapsLk' key and the 'Tab' key be interpreted as a space). One would think that a single keycode (physical key) can only have one keysym (interpretation). However, the mapping will maintain multiple keysyms for a single keycode because the same physical key combined with modifier keys can give different keysyms. There are up to 8 modifier keys which, when combined with other keys, can result in different keysyms. Only 4 of these modifier keys are portable (shift, control, alt, capslock). The modifier map is an association of these 8 modifiers with the keycodes that generate them. Some of the modifier names shown below are shift, lock, control, mod1. The default keycodes that map to these modifiers are named similarly, but we are allowed to map them however we wish. That is, we could have the keycode 'Control_L (0x25)'  map to the 'shift' modifier if we'd like.

! The second responsibility of the X server is to report its key events (KeyPress or KeyRelease) to the appropriate clients. What it actually reports is the keycode pressed along with the modifier. For example, suppose I type a capital 'A'. Then the client associated with the window that I typed the letter into receives 1) the keycode associated with the "a" key on the keyboard, and 2) the modifier "shift". That is, it will get a piece of data like (38, shift). What this means is that the X server had to check if any of the keycodes entered correspond to a modifier, and if it did, send that to the client as a modifier. The client then checks the keycode->keysym map: 38 is the keycode, and the shift informs the client which of the keysyms to translate the keycode into.

! The usage of xmodmap keymap and keysym expressions is well explained in the man pages. As for the modifiers, we can get the modifier map with the command `xmodmap -pm'. Confusingly, to add to the modifier map we must provide a keysym rather than a keycode. For example, the command `xmodmap -e "add control = Control_L" ' will have xmodmap first figure out what keycodes correspond to the keysym Control_L, and enter those keycodes as entries under the 'control' modifier. Thus if for example, <Shift><A>, the capital 'A' from our previous example, mapped to the Control_L keysym, then the command would have not only the Control_L (0x25) entry but also a Control_L (0x26) entry since the keycode for the letter 'A' is 38.

! Original Modifier Map

! shift       Shift_L (0x32),  Shift_R (0x3e)
! lock        Caps_Lock (0x42)
! control     Control_L (0x25),  Control_R (0x69)
! mod1        Alt_L (0x40),  Alt_R (0x6c),  Meta_L (0xcd)
! mod2        Num_Lock (0x4d)
! mod3      
! mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce),  Hyper_L (0xcf)
! mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)

! Make the Caps_Lock another Control

keysym Caps_Lock = Control_L
clear Lock

! At this point, the modifier map has no entries for the 'lock' modifier. The Control_L entry for the 'control' modifier is a "stale" entry since there is now another keycode (0x42) associated with the Control_L besides (0x25). We will refresh this entry by removing and re-adding it.

remove control = Control_L
add control = Control_L

